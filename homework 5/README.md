# Строка 110201
Тщетно пытался понять, почему запрос на строке столь отличается от
всех других. В работе запись лога признана ошибочной и поэтому
игнорируется.

# Python

## Запуск
Выполнить `script_python.py`

### Флаги

`--file путь` - указать путь к логу (от корня репозитория)

`--json` - сохранить собранные данные в JSON

## Принцип работы
Запись осуществляется в `/tmp/parsed_log/by_python`.
Строки лога считываются в список `lines_log`, в процессе чего
разделяются по пробелу. Также происходит отсеивание ошибочных
записей - включение в список происходит, лишь если значимая часть
элемента №5 (`"тип_запроса`) строки содержится в списке типов запросов
`TYPES_REQUESTS`. В процессе шагов ниже переменная `string_output`
пополняется необходимыми данными и в конце записывается в файл.

1) **Общее количество запросов**

   Вычисляется длина списка строк лога.


2) **Общее количество запросов по типу**

   Создаётся словарь: ключи - типы запросов, значения везде - 0. 
   Значимая часть элемента №5 каждой строки лога используется, как
   ключ для словаря - значение увеличивается на 1. В строку вывода
   записываются типы запросов и соответствующие им значения из словаря.


3) **Топ 10 самых частых запросов**

   Создаётся список из элементов №6 (`url`) каждой строки лога. 
   При помощи `collections.Counter` выявляется топ 10 самых частых.


4) **Топ 5 самых больших по размеру запросов, которые завершились
   клиентской ошибкой**

   Создаётся список из элементов №6, №8 (`статус_код`), №9 
   (`размер_запроса`) и №0 (`ip_адрес`) тех строк лога, у которых 
   элемент №8 начинается с "4". Происходит сортировка по бывшему 
   элементу №9 в обратном порядке.


5) **Топ 5 пользователей по количеству запросов, которые завершились
   серверной ошибкой**

   Создаётся список из элементов №0 тех строк лога, у которых элемент 
   №8 начинается с "5". При помощи `collections.Counter` выявляется 
   топ 5 самых частых.


# Bash

## Запуск
Выполнить `script_bash.sh путь_к_логу_от_корня_репозитория`

## Принцип работы
Запись осуществляется в `/tmp/parsed_log/by_bash`.
При помощи `grep` создаётся файл с копией лога без ошибочных
записей - строки лога помещаются в файл, лишь если содержат запрос
с одним из типов запросов (массив `TYPES_REQUESTS`). Вывод,
полученный в процессе шагов ниже, записывается в файл.

1) **Общее количество запросов**

   При помощи `wc` вычисляется количество строк лога.


2) **Общее количество запросов по типу**

   Для каждого элемента массива типов запросов `grep` выявляет 
   количество подходящих записей в логе - ищется
   `начало_строки любые_символы "тип_запроса`.


3) **Топ 10 самых частых запросов**
   
   `grep` получает `url` каждой строки лога - ищется
   `начало_строки любые_символы " любые_символы пробел 
   началo_захвата любые_символы захват_до_пробела`. `sort`
   сортирует это, тем самым помещая одинаковые запросы рядом. `uniq`
   унифицирует рядом расположенные одинаковые запросы, выводя
   количество унифицированных вместе с оставшимся. `sort` сортирует
   это в обратном порядке. `head` получает первые 10 запросов.
   `awk` делает вывод с форматированием.


4) **Топ 5 самых больших по размеру запросов, которые завершились
   клиентской ошибкой**

   `grep` получает каждую подходящую строку лога - ищется
   `начало_строки любые_символы " любые_символы " пробел 4`.
   `awk` дублирует размеры запросов перед строками. `sort` сортирует 
   это в обратном порядке. `head` получает первые 5 запросов. `awk`
   делает вывод с форматированием.


5) **Топ 5 пользователей по количеству запросов, которые завершились
   серверной ошибкой**

   `grep` получает каждый подходящий `ip_адрес` - ищется
   `начало_строки любые_символы захват_до(пробел любые_символы "
   любые_символы " пробел 5)`. `sort` сортирует это. `uniq`
   унифицирует запросы, выводя количество. `sort` сортирует это в
   обратном порядке. `head` получает первые 5 запросов. `awk`
   делает вывод с форматированием.